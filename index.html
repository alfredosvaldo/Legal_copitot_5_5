<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Copiloto Legal: Comparador Legislativo Inteligente (OpenAI)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Export to Word -->
  <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <!-- Diff -->
  <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    #resultsTable th, #resultsTable td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
    #resultsTable th { background-color: #f2f2f2; text-align: left; }
    .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
              width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 2rem auto; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    ins { background-color: #d4edda; text-decoration: none; }
    del { background-color: #f8d7da; text-decoration: line-through; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content { background: #fff; padding: 2rem; border-radius: .5rem; width: 420px; max-width: 90%; text-align: center; }
    .modal-button { margin-top: 1.2rem; padding: .5rem 1.2rem; background: #2563eb; color: #fff; border-radius: .375rem; font-weight: 600; cursor: pointer; }
    pre code { white-space: pre-wrap; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col min-h-screen">
  <div class="container mx-auto p-4 md:p-8 flex-grow">
    <header class="text-center mb-8">
      <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Copiloto Legal</h1>
      <p class="text-gray-600 mt-2">Genera indicaciones y tablas comparativas de textos legales</p>
    </header>

    <!-- Credenciales / configuración -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-6">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div class="md:col-span-2">
          <label for="apiKey" class="block text-lg font-semibold mb-2">Your OpenAI API Key</label>
          <input type="password" id="apiKey" class="w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pega tu API key aquí">
          <div class="flex items-center mt-2">
            <input type="checkbox" id="rememberKey" class="mr-2" />
            <label for="rememberKey" class="text-sm text-gray-600">Recordar clave en este navegador</label>
          </div>
          <p class="text-sm text-gray-500 mt-1">La clave se guarda sólo en tu navegador (localStorage).</p>
        </div>
        <div class="space-y-3">
          <div>
            <label for="modelSelect" class="block text-sm font-medium text-gray-700">Modelo</label>
            <select id="modelSelect" class="w-full mt-1 p-2 border rounded-md">
              <option value="gpt-5">gpt-5 (standard)</option>
              <option value="gpt-5-reasoning">gpt-5 (reasoning)</option>
              <option value="gpt-5-mini" selected>gpt-5-mini (rápido)</option>
              <option value="gpt-4.1">gpt-4.1</option>
              <option value="gpt-4o">gpt-4o</option>
            </select>
          </div>
          <div>
            <label for="endpointSelect" class="block text-sm font-medium text-gray-700">Endpoint</label>
            <select id="endpointSelect" class="w-full mt-1 p-2 border rounded-md">
              <option value="responses" selected>v1/responses (recomendado)</option>
              <option value="chat">v1/chat/completions</option>
            </select>
            <p class="text-xs text-gray-500 mt-1">Sugerido automáticamente por modelo (puedes cambiarlo).</p>
          </div>
          <div class="flex items-center gap-2">
            <input type="checkbox" id="streamToggle" checked />
            <label for="streamToggle" class="text-sm text-gray-700">Streaming (si tu org lo permite)</label>
          </div>
        </div>
      </div>
    </div>

    <!-- Entradas -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold mb-4">Texto Original Completo</h2>
        <textarea id="originalText" class="w-full h-96 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pegue aquí la columna completa del texto original..."></textarea>
      </div>
      <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold mb-4">Texto Final Completo</h2>
        <textarea id="finalText" class="w-full h-96 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pegue aquí la columna completa del texto final modificado..."></textarea>
      </div>
    </div>

    <!-- Acciones -->
    <div class="text-center my-8">
      <button id="generateButton" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition disabled:bg-gray-400 disabled:cursor-not-allowed">
        Generar Tabla Comparativa
      </button>
    </div>

    <!-- Salida -->
    <div id="outputSection" class="bg-white p-6 rounded-lg shadow-md hidden">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-semibold">Resultado Comparativo
          <span id="timerResult" class="text-sm font-normal text-gray-500 ml-2"></span>
        </h2>
        <button id="exportButton" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Exportar a Word</button>
      </div>

      <div class="mb-4">
        <div class="text-xs text-gray-500 mb-1">Salida en vivo</div>
        <pre id="streamOutput" class="w-full whitespace-pre-wrap text-sm text-gray-700 border rounded p-3 bg-gray-50"></pre>
      </div>

      <div id="resultsContainer" class="w-full overflow-x-auto"></div>
      <div id="errorBox" class="hidden mt-4 border border-red-200 bg-red-50 text-red-700 text-sm rounded p-3"></div>
    </div>
  </div>

  <footer class="text-center p-4 text-gray-500 text-sm">
    <p>Copiloto Legal v5.8 (MaxTokens + Auto-Continuación) · Últ. act.: 27 Ago 2025</p>
  </footer>

  <!-- Modal -->
  <div id="customAlert" class="modal-backdrop hidden">
    <div class="modal-content">
      <p id="alertMessage"></p>
      <button id="alertCloseButton" class="modal-button">Cerrar</button>
    </div>
  </div>

<script>
/* ============ Modelo ↔ Endpoint sugerido ============ */
const MODEL_PRESETS = {
  'gpt-5':             { id: 'gpt-5',             preferredEndpoint: 'responses' },
  'gpt-5-reasoning':   { id: 'gpt-5-reasoning',   preferredEndpoint: 'responses' },
  'gpt-5-mini':        { id: 'gpt-5-mini',        preferredEndpoint: 'responses' },
  'gpt-4.1':           { id: 'gpt-4.1',           preferredEndpoint: 'chat' },
  'gpt-4o':            { id: 'gpt-4o',            preferredEndpoint: 'chat' }
};

const modelSelect = document.getElementById('modelSelect');
const endpointSelect = document.getElementById('endpointSelect');
let endpointUserEdited = false;
endpointSelect.addEventListener('change', () => { endpointUserEdited = true; });
modelSelect.addEventListener('change', () => {
  const key = modelSelect.value;
  const preferred = MODEL_PRESETS[key]?.preferredEndpoint;
  if (!endpointUserEdited && preferred) endpointSelect.value = preferred;
  sessionStorage.clear();
});

/* ============ Persistencia de API key ============ */
const apiKeyInput = document.getElementById('apiKey');
const rememberKey  = document.getElementById('rememberKey');
if (localStorage.getItem('openai_api_key')) {
  apiKeyInput.value = localStorage.getItem('openai_api_key');
  rememberKey.checked = true;
}
rememberKey.addEventListener('change', ()=>{ if(!rememberKey.checked) localStorage.removeItem('openai_api_key'); });

/* ============ UI helpers ============ */
document.getElementById('generateButton').addEventListener('click', generateIndications);
document.getElementById('exportButton').addEventListener('click', exportToWord);
document.getElementById('alertCloseButton').addEventListener('click',()=>{ document.getElementById('customAlert').classList.add('hidden'); });

function showAlert(m){ document.getElementById('alertMessage').textContent = m; document.getElementById('customAlert').classList.remove('hidden'); }
function showErrorBox(obj){
  const box = document.getElementById('errorBox');
  box.classList.remove('hidden');
  box.innerHTML = `<pre>${typeof obj==='string' ? obj : JSON.stringify(obj, null, 2)}</pre>`;
}

/* ============ Parser & Renderer ============ */
function parseCustomFormat(responseText) {
  const articles = [];
  const blocks = responseText.split('<ARTICLE_END>');
  for (const b of blocks) {
    if (!b.trim()) continue;
    const o = b.match(/<ORIGINAL>([\s\S]*?)<\/ORIGINAL>/);
    const i = b.match(/<INDICACIONES>([\s\S]*?)<\/INDICACIONES>/);
    const f = b.match(/<FINAL>([\s\S]*?)<\/FINAL>/);
    if (o && i && f) {
      articles.push({
        textoOriginal: (o[1] || '').trim(),
        indicaciones:  (i[1] || '').trim(),
        textoFinal:    (f[1] || '').trim()
      });
    }
  }
  return articles;
}

function renderTable(articles) {
  const container = document.getElementById('resultsContainer');
  container.innerHTML = '';
  if (!articles.length) {
    container.innerHTML = '<p class="text-red-500">No se pudieron procesar artículos.</p>';
    return;
  }
  const table = document.createElement('table');
  table.id = 'resultsTable';
  table.className = 'w-full border-collapse';
  table.innerHTML = '<thead><tr>' +
    '<th class="w-1/3 p-2 border bg-gray-100">Texto Original (con cambios)</th>' +
    '<th class="w-1/3 p-2 border bg-gray-100">Indicaciones Generadas</th>' +
    '<th class="w-1/3 p-2 border bg-gray-100">Texto Final (con cambios)</th>' +
  '</tr></thead>';
  const tbody = document.createElement('tbody');

  articles.forEach(a => {
    const diff = Diff.diffWords(a.textoOriginal || '', a.textoFinal || '', { ignoreWhitespace: true });
    let originalHtml = '', finalHtml = '';
    diff.forEach(part => {
      const v = part.value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      if (part.added)      finalHtml   += `<ins>${v}</ins>`;
      else if (part.removed) originalHtml += `<del>${v}</del>`;
      else { originalHtml += v; finalHtml += v; }
    });
    tbody.innerHTML += `
      <tr>
        <td class="p-2 border align-top whitespace-pre-wrap">${originalHtml}</td>
        <td class="p-2 border align-top whitespace-pre-wrap">${(a.indicaciones||'').replace(/\n/g,'<br>')}</td>
        <td class="p-2 border align-top whitespace-pre-wrap">${finalHtml}</td>
      </tr>`;
  });

  table.appendChild(tbody);
  container.appendChild(table);
  document.getElementById('outputSection').classList.remove('hidden');
}

/* ============ SSE readers ============ */
async function readSSE_Responses(response, onDelta) {
  if (!response.ok) { let e; try{ e = await response.json(); } catch { e = await response.text(); } throw { httpStatus: response.status, error: e }; }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const raw of lines) {
      if (!raw.startsWith('data:')) continue;
      const data = raw.slice(5).trim();
      if (data === '[DONE]') return;
      try {
        const obj = JSON.parse(data);
        if (obj.type === 'response.output_text.delta' && typeof obj.delta === 'string') onDelta(obj.delta);
        else if (obj.type === 'response.delta') {
          const t = obj.delta?.output_text || obj.delta?.text || '';
          if (t) onDelta(t);
        } else if (obj.type === 'message.delta') {
          const t = obj.delta?.content?.map(c => c?.text || '').join('') || '';
          if (t) onDelta(t);
        }
      } catch {}
    }
  }
}
async function readSSE_Chat(response, onDelta) {
  if (!response.ok) { let e; try{ e = await response.json(); } catch { e = await response.text(); } throw { httpStatus: response.status, error: e }; }
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const raw of lines) {
      if (!raw.startsWith('data:')) continue;
      const data = raw.slice(5).trim();
      if (data === '[DONE]') return;
      try {
        const obj = JSON.parse(data);
        const delta = obj?.choices?.[0]?.delta?.content;
        if (typeof delta === 'string') onDelta(delta);
      } catch {}
    }
  }
}

/* ============ Probe de streaming por sesión ============ */
async function probeStreaming({ apiKey, endpoint, model }) {
  const key = `probe:${endpoint}:${model}`;
  const cached = sessionStorage.getItem(key);
  if (cached === 'ok') return true;
  if (cached === 'no') return false;

  try {
    if (endpoint === 'responses') {
      const res = await fetch('https://api.openai.com/v1/responses', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model, input: 'ping', stream: true })
      });
      if (!res.ok) {
        let j = {}; try { j = await res.json(); } catch {}
        if (j?.error?.param === 'stream') { sessionStorage.setItem(key, 'no'); return false; }
        throw j;
      }
      const r = res.body.getReader(); await r.read(); r.cancel().catch(()=>{});
      sessionStorage.setItem(key, 'ok'); return true;
    } else {
      const res = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model, messages: [{ role: 'user', content: 'ping' }], stream: true })
      });
      if (!res.ok) {
        let j = {}; try { j = await res.json(); } catch {}
        if (j?.error?.param === 'stream') { sessionStorage.setItem(key, 'no'); return false; }
        throw j;
      }
      const r = res.body.getReader(); await r.read(); r.cancel().catch(()=>{});
      sessionStorage.setItem(key, 'ok'); return true;
    }
  } catch (_) {
    sessionStorage.setItem(key, 'no');
    return false;
  }
}

/* === helper: plan de max tokens por intento (evita truncados en multi-artículo) === */
function makeMaxTokenPlan(model, endpoint, approxChars) {
  if (endpoint === 'responses') return [8192, 4096, 2048, 1024];
  return [4096, 2048, 1024, 512];
}

/* === helpers: detectar truncado y preparar continuación === */
function extractLastBlock(fullText) {
  const idx = fullText.lastIndexOf('<ARTICLE_START>');
  if (idx === -1) return '';
  return fullText.slice(idx);
}
function getLastGlobalIndex(block) {
  let last = 0;
  const re = /[\n\r]\s*(\d+)\)\s/gm; // numerales "1) 2) 3) ..."
  let m;
  while ((m = re.exec(block)) !== null) {
    const n = parseInt(m[1], 10);
    if (!isNaN(n) && n > last) last = n;
  }
  return last;
}
function needsContinuation(fullText) {
  const starts = (fullText.match(/<ARTICLE_START>/g) || []).length;
  const ends   = (fullText.match(/<ARTICLE_END>/g)   || []).length;
  if (starts > ends) return true;
  if (starts === 0) return true;
  return false;
}

/* === Reparación suave de unidad (inciso vs oración) === */
function softUnitRepair(rawText) {
  const lines = rawText.split('\n');
  const reNuevoInciso = /(nuevo\s+inciso|como\s+inciso)/i;
  const reOracionFrase = /(la\s+oración|la\s+frase|la\s+expresión|la\s+palabra)/i;

  for (let i = 0; i < lines.length; i++) {
    const L = lines[i];
    if (reNuevoInciso.test(L) && reOracionFrase.test(L)) {
      lines[i] = L
        .replace(/nuevo\s+inciso/gi, 'la oración')
        .replace(/como\s+inciso/gi, 'la oración')
        .replace(/Para\s+agregar/gi, 'Para incorporar')
        .replace(/Para\s+introducir/gi, 'Para incorporar');
    }
  }
  return lines.join('\n');
}

/* ============ Motor de llamadas con fallback (respeta tu elección) ============ */
async function generateIndications() {
  const apiKey = apiKeyInput.value;
  const modelKey = modelSelect.value;
  const selectedModelId = MODEL_PRESETS[modelKey]?.id || modelKey;

  const selectedEndpoint = endpointSelect.value || MODEL_PRESETS[modelKey]?.preferredEndpoint || 'responses';
  const wantStreaming = document.getElementById('streamToggle')?.checked ?? true;

  const originalText = document.getElementById('originalText').value;
  const finalText    = document.getElementById('finalText').value;

  if (!apiKey) return showAlert('Ingresa tu API key.');
  if (!originalText.trim() || !finalText.trim()) return showAlert('Pega texto en ambas columnas.');
  if (rememberKey.checked) localStorage.setItem('openai_api_key', apiKey);

  const resultsContainer = document.getElementById('resultsContainer');
  const outputSection    = document.getElementById('outputSection');
  const generateButton   = document.getElementById('generateButton');
  const timerResult      = document.getElementById('timerResult');
  const streamOutput     = document.getElementById('streamOutput');
  const errorBox         = document.getElementById('errorBox');

  errorBox.classList.add('hidden');
  generateButton.disabled = true;
  generateButton.textContent = 'Generando...';
  outputSection.classList.remove('hidden');
  resultsContainer.innerHTML = '<div class="loader"></div>';
  streamOutput.textContent = '';
  timerResult.textContent = '';

  const startTime = performance.now();
  const timer = setInterval(() => {
    const sec = ((performance.now() - startTime) / 1000).toFixed(1);
    timerResult.textContent = `Generando… ${sec}s`;
  }, 250);

  // PROMPT
  const prompt = `Rol: Eres un asesor legislativo experto en Chile, con especialización en técnica parlamentaria. Tu misión es generar una comparación completa, artículo por artículo, de dos textos legales, produciendo indicaciones precisas y profesionales que se adhieran estrictamente a la terminología oficial.

1) GLOSARIO DE TÉRMINOS (USO OBLIGATORIO)
- Verbos de acción (normativos):
• Para adicionar información: "Incorpórase", "Agrégase", "Añádese".
• Para sustituir información: "Sustitúyese", "Reemplázase".
• Para adicionar entre vocablos: "Intercálese".
• Para eliminar información: "Suprímese", "Elimínase".
• Para modificar de forma genérica: "Modifícase".
- Sustantivos para designar elementos: "el guarismo", "la expresión", "la palabra", "la frase", "la oración", "el numeral", "el literal", "el inciso", "el artículo", "el encabezado", "la sección (i), (ii), (iii)…".
- Meta-frase para iniciar cada indicación numerada (nivel principal): "Para + infinitivo" (ej.: Para reemplazar…, Para modificar…, Para agregar…). En los desgloses a), b), c) usa solo los verbos normativos del glosario.

2) REGLAS DE ORO (MÁXIMA PRIORIDAD)
- Numeración correlativa global: la secuencia 1), 2), 3)… es continua a lo largo de TODO el documento (no se reinicia por artículo).
- Procesar todo y en orden: recorre los textos de principio a fin y genera un bloque para CADA artículo.
- Encabezado único por artículo (obligatorio): Dentro de <INDICACIONES>, escribe una sola vez la línea: AL ARTÍCULO [nombre completo] (sin dos puntos al final) y debajo coloca todas las indicaciones numeradas aplicables a ese artículo. "Nombre completo" = denominación exacta (p. ej., "Artículo 11", "Artículo tercero transitorio", ordinales/letras/romanos y/o epígrafe).
- Agrupación de cambios:
• Genera UNA indicación por unidad afectada (inciso, numeral, literal, sección, encabezado, “nuevo inciso [ordinal] introducido al artículo X”, etc.).
• Si varios cambios coherentes afectan una MISMA unidad (o varias partes del mismo artículo bajo un objetivo común), puedes agruparlos en UNA sola indicación usando la frase: "en el siguiente sentido:" y desglosando con a), b), c)… (usando verbos normativos).

2.b) REGLAS FINAS DE UNIDAD (OBLIGATORIAS)
Nunca confundas oración/frase/expresión/palabra/guarismo con inciso/numeral/literal.
Decisión:
- Si el mandato usa “la oración”, “la frase”, “la expresión”, “la palabra” ⇒ NO es un nuevo inciso. Es inserción o sustitución dentro del mismo inciso.
- Usa:
  • Para agregar: “Incorpórase, a continuación de «___», la **oración** «___».”
  • Para intercalar: “Intercálese, entre «___» y «___», la **oración** «___».”
  • Para reemplazar: “Sustitúyese la **expresión** «___» por «___».”
- Solo llamar “nuevo inciso” cuando el texto nombre expresamente “inciso primero/segundo/tercero…”, “inciso nuevo”, o sea un párrafo independiente identificable como inciso.
- Prohibido redactar “nuevo inciso” si el texto dice “la oración”, “la frase” o similares.
- Si dudas, prefiere “oración/frase” y no “nuevo inciso”.
Validación interna: si una indicación contiene “nuevo inciso” y también “oración/frase/expresión/palabra/guarismo”, corrige a inserción/intercalación/sustitución.

3) FORMATO DE SALIDA ESTRICTO (OBLIGATORIO)
Toda la respuesta debe usar estas etiquetas (no uses JSON).
<ARTICLE_START>
<ORIGINAL>...texto original aquí (si aplica)...</ORIGINAL>
<INDICACIONES>
AL ARTÍCULO [nombre completo]
1) Para [verbo en infinitivo] ...
2) Para [verbo en infinitivo] ...
a) [Verbo normativo] ...
b) [Verbo normativo] ...
3) Para [verbo en infinitivo] ...
</INDICACIONES>
<FINAL>...texto final aquí (si aplica)...</FINAL>
<ARTICLE_END>
... (repetir para cada artículo) ...

Si no hay cambios para un artículo, deja <INDICACIONES> vacío (sin encabezado ni numerales).

4) PROCESO DE ANÁLISIS SECUENCIAL E ITERATIVO
Paso 1 — Identificar artículo: toma el siguiente en secuencia (p. ej., "Artículo 2°", "Artículo tercero transitorio").
Paso 2 — Determinar el caso:
CASO A: MODIFICACIÓN (existe en ambos textos con el mismo número)
- Regla de agrupación:
• Una indicación por unidad afectada (inciso, numeral, literal, sección, encabezado…).
• Si hay múltiples cambios en la MISMA unidad, usa: N) Para modificar [la unidad] en el siguiente sentido: a) [Verbo normativo] ... b) [Verbo normativo] ...
- Plantillas:
• N) Para reemplazar en el [inciso/numeral/literal/sección (ii)] [del artículo X], el guarismo "___" por "___".
• N) Para agregar, en el [inciso/numeral/literal], a continuación de "___", la frase "___".
• N) Para modificar [inciso primero] en el siguiente sentido: a) Suprímese la expresión "___". b) Incorpórase, entre "___" y "___", la frase "___".
CASO B: ARTÍCULO NUEVO (solo en el Texto Final)
- <ORIGINAL> vacío.
- <INDICACIONES>: AL ARTÍCULO [nombre completo] N) Para agregar el siguiente artículo [nombre completo], nuevo, del siguiente tenor: "___".
- <FINAL> contiene el texto completo nuevo.
CASO C: ARTÍCULO ELIMINADO (solo en el Texto Original)
- <ORIGINAL> contiene el texto del artículo.
- <INDICACIONES>: AL ARTÍCULO [nombre completo] N) Para suprimir el artículo [nombre completo].
- <FINAL> vacío.
CASO D: RENUMERACIÓN (contenido del "Artículo X" original es idéntico al del "Artículo Y" final)
- <ORIGINAL> contiene el texto del artículo X.
- <INDICACIONES>: AL ARTÍCULO [nombre completo del original X] N) Para consignar que el artículo X ha pasado a ser artículo Y.
- <FINAL> contiene el texto del artículo Y.
Paso 3 — Construir bloque de salida: encierra cada resultado en <ARTICLE_START> … <ARTICLE_END>.
Paso 4 — Continuar: al cerrar <ARTICLE_END>, procesa de inmediato el siguiente artículo.

5) REGLA FINAL DE COMPLETITUD
No te detengas hasta procesar TODOS los artículos del Texto Original y del Texto Final. Continúa generando bloques <ARTICLE_START>…<ARTICLE_END> hasta cubrir ambos completamente.

6) TEXTOS A PROCESAR
Texto Original: ${originalText}
Texto Final: ${finalText}`;

  try {
    // PRIMER LOTE
    const firstText = await autoCall({
      apiKey,
      models:    [ selectedModelId, 'gpt-4.1', 'gpt-4o' ],
      endpoints: [ selectedEndpoint, (selectedEndpoint === 'responses' ? 'chat' : 'responses') ],
      wantStreaming,
      prompt,
      out: document.getElementById('streamOutput')
    });

    let combined = firstText;

    // Si se detecta truncado, pedimos continuaciones por lotes (máx 4)
    let steps = 0;
    const MAX_CONT_STEPS = 4;
    while (needsContinuation(combined) && steps < MAX_CONT_STEPS) {
      steps++;
      const lastBlock = extractLastBlock(combined);
      const lastIdx = getLastGlobalIndex(lastBlock);
      const contHeader = `\n\n[Continuación automática ${steps}/${MAX_CONT_STEPS}] Último índice global detectado: ${lastIdx}.\n`;
      document.getElementById('streamOutput').textContent += contHeader;

      const continuePrompt = `CONTINUACIÓN ESTRICTA — LOTE ${steps}
Debes CONTINUAR la salida exactamente donde quedó, sin repetir bloques ya emitidos.
Devuelve EXCLUSIVAMENTE nuevos bloques <ARTICLE_START> ... </ARTICLE_END>.
Mantén la numeración correlativa global continuando desde ${lastIdx + 1}).
No reinicies ni reformatees nada.

Referencia del último bloque emitido (para contexto de numeración y estilo):
${lastBlock.slice(0, 2000)}

Recuerda: Solo devuelve los NUEVOS bloques <ARTICLE_START> ... </ARTICLE_END>, en el mismo formato exacto, hasta seguir avanzando en los textos.`;

      const contText = await autoCall({
        apiKey,
        models:    [ selectedModelId, 'gpt-4.1', 'gpt-4o' ],
        endpoints: [ selectedEndpoint, (selectedEndpoint === 'responses' ? 'chat' : 'responses') ],
        wantStreaming,
        prompt: `${prompt}\n\n${continuePrompt}`,
        out: document.getElementById('streamOutput')
      });

      if (!contText || !contText.includes('<ARTICLE_START>')) break;

      const newPart = contText.replace(lastBlock, '');
      combined += newPart;
    }

    // Reparación suave por si mini confundió "nuevo inciso" con "oración"
    const repaired = softUnitRepair(combined);
    renderTable(parseCustomFormat(repaired));

  } catch (err) {
    console.error(err);
    showErrorBox(err);
    const rc = document.getElementById('resultsContainer');
    if (rc) rc.innerHTML = '<p class="text-red-500">No se pudieron procesar artículos.</p>';
  } finally {
    clearInterval(timer);
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
    timerResult.textContent = `Generado en ${elapsed}s`;
    generateButton.disabled = false;
    generateButton.textContent = 'Generar Tabla Comparativa';
  }
}

/* ============ Orden inteligente + cache de fallos + probe streaming ============ */
async function autoCall({ apiKey, models, endpoints, wantStreaming, prompt, out }) {
  const triedKey = (e, m) => `bad:${e}:${m}`;
  const approxChars = prompt.length;

  for (const e of endpoints) {
    for (const m of models) {
      if (sessionStorage.getItem(triedKey(e, m)) === 'bad') continue;

      let doStream = wantStreaming;
      if (doStream) {
        const ok = await probeStreaming({ apiKey, endpoint: e, model: m });
        if (!ok) { out.textContent += `\n[Streaming no habilitado para ${e}+${m}. Usaremos no-stream]\n`; doStream = false; }
      }

      const maxPlan = makeMaxTokenPlan(m, e, approxChars);

      out.textContent += `\n→ Probando ${e} con ${m}${doStream ? ' [stream]' : ''}...\n`;
      try {
        const text = await callOnce({
          apiKey, endpoint: e, model: m, stream: doStream,
          prompt, outEl: out, maxPlan
        });
        out.textContent += `\n✓ OK con ${e} + ${m}${doStream ? ' [stream]' : ''}\n`;
        return text;
      } catch (err) {
        sessionStorage.setItem(triedKey(e, m), 'bad');
        out.textContent += `✖ Error ${err?.httpStatus || ''}. Seguimos probando...\n`;
      }
    }
  }
  throw { error: 'No hubo combinación válida (modelo/endpoint). Revisa permisos del modelo o usa gpt-4.1 / gpt-4o.' };
}

/* ============ Llamada única (Responses / Chat) con plan de max tokens ============ */
async function callOnce({ apiKey, endpoint, model, stream, prompt, outEl, maxPlan }) {
  const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
  const plan = Array.isArray(maxPlan) && maxPlan.length ? maxPlan.slice()
               : (endpoint === 'responses' ? [8192, 4096, 2048, 1024] : [4096, 2048, 1024, 512]);

  let lastErr = null;

  for (const limit of plan) {
    try {
      outEl.textContent += `   ↳ max_${endpoint === 'responses' ? 'output_' : ''}tokens=${limit}\n`;

      if (endpoint === 'responses') {
        const url = 'https://api.openai.com/v1/responses';
        if (stream) {
          const body = { model, input: prompt, stream: true, max_output_tokens: limit };
          const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
          if (!res.ok) {
            let err; try { err = await res.json(); } catch { err = await res.text(); }
            if (err?.error?.param === 'max_output_tokens' || /max_output_tokens/i.test(JSON.stringify(err))) {
              lastErr = { httpStatus: res.status, error: err, sent: body }; continue;
            }
            throw { httpStatus: res.status, error: err, sent: body };
          }
          let full = '';
          await readSSE_Responses(res, (delta) => { full += delta; outEl.textContent += delta; });
          return full;
        } else {
          const body = { model, input: prompt, max_output_tokens: limit };
          const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
          const j = await res.json().catch(()=>({}));
          if (!res.ok) {
            if (j?.error?.param === 'max_output_tokens' || /max_output_tokens/i.test(JSON.stringify(j))) {
              lastErr = { httpStatus: res.status, error: j, sent: body }; continue;
            }
            throw { httpStatus: res.status, error: j, sent: body };
          }
          const text = (typeof j.output_text === 'string')
            ? j.output_text
            : (Array.isArray(j.output)
                ? j.output.map(m => (m.content || []).map(c => c.text || '').join('')).join('')
                : '');
          return text || '';
        }
      } else {
        const url = 'https://api.openai.com/v1/chat/completions';
        if (stream) {
          const body = { model, messages: [{ role: 'user', content: prompt }], stream: true, max_tokens: limit };
          const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
          if (!res.ok) {
            let err; try { err = await res.json(); } catch { err = await res.text(); }
            if (err?.error?.param === 'max_tokens' || /max_tokens/i.test(JSON.stringify(err))) {
              lastErr = { httpStatus: res.status, error: err, sent: body }; continue;
            }
            throw { httpStatus: res.status, error: err, sent: body };
          }
          let full = '';
          await readSSE_Chat(res, (delta) => { full += delta; outEl.textContent += delta; });
          return full;
        } else {
          const body = { model, messages: [{ role: 'user', content: prompt }], max_tokens: limit };
          const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
          const j = await res.json().catch(()=>({}));
          if (!res.ok) {
            if (j?.error?.param === 'max_tokens' || /max_tokens/i.test(JSON.stringify(j))) {
              lastErr = { httpStatus: res.status, error: j, sent: body }; continue;
            }
            throw { httpStatus: res.status, error: j, sent: body };
          }
          return j?.choices?.[0]?.message?.content || '';
        }
      }
    } catch (e) {
      if (e?.error?.param !== 'max_output_tokens' && e?.error?.param !== 'max_tokens') throw e;
      lastErr = e;
    }
  }
  throw (lastErr || { error: 'Token plan exhausted' });
}

/* ============ Export a Word ============ */
function exportToWord() {
  const table = document.getElementById('resultsTable');
  if (!table) return showAlert('No hay resultados para exportar.');
  const html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
    <style>
      body{font-family:'Times New Roman', Times, serif;}
      table{border-collapse:collapse;width:100%}
      th,td{border:1px solid #000;padding:8px;vertical-align:top;white-space:pre-wrap}
      th{background:#f2f2f2}
      ins{background:#d4edda;color:#000;text-decoration:none}
      del{background:#f8d7da;color:#000;text-decoration:line-through}
    </style></head>
    <body><h1>Tabla Comparativa de Indicaciones</h1>${table.outerHTML}</body></html>`;
  saveAs(htmlDocx.asBlob(html), 'Tabla_Comparativa_Indicaciones.docx');
}

/* ============ Handlers globales de errores (para depurar rápido) ============ */
window.addEventListener('error', (ev) => {
  console.error('window.error:', ev.error || ev.message);
  if (typeof showErrorBox === 'function') showErrorBox(ev.error || ev.message);
});
window.addEventListener('unhandledrejection', (ev) => {
  console.error('unhandledrejection:', ev.reason);
  if (typeof showErrorBox === 'function') showErrorBox(ev.reason);
});
</script>
</body>
</html>
